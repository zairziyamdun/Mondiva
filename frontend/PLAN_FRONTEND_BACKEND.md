# План улучшения фронтенда и связи с бэкендом MonDiva

## 1. Текущее состояние фронтенда

### Данные и API
- **Все данные из моков**: `lib/mock-data.ts` — категории, товары, пользователи, заказы, отзывы, возвраты.
- **Нет вызовов API**: ни одного `fetch()` / axios к бэкенду.
- **Нет переменной окружения** для URL API (`NEXT_PUBLIC_API_URL`).

### Авторизация
- **Логин** (`app/auth/login/page.tsx`): форма не вызывает API, при submit — редирект на `/account`.
- **Регистрация** (`app/auth/register/page.tsx`): то же самое, редирект без создания пользователя.
- **Токены не хранятся**: нет accessToken, нет refresh (cookie приходит с бэка, но запросы с фронта не отправляются).
- **Хедер**: всегда показывает «Войти» / «Регистрация», не отображает авторизованного пользователя и «Выйти».

### Страницы и источники данных
| Страница / компонент | Источник данных | Замечание |
|----------------------|-----------------|-----------|
| Главная | `mock-data`: categories, products | Новинки, популярное, скидки, категории — всё из мока |
| Каталог | `catalog-content.tsx` → products, categories | Фильтрация и сортировка на клиенте |
| Товар `/product/[id]` | `products.find(p => p.id === id)` | Поддерживается только строковый id; бэкенд отдаёт `_id` (ObjectId) и slug |
| Корзина | `cart-store.ts` (память) | При перезагрузке корзина пустая |
| Checkout | `cart-store` + локальный state | Заказ не отправляется на API, только `clearCart()` и «Заказ оформлен» |
| Аккаунт | `mock-data`: users[0], orders, returnRequests, products | Нет привязки к текущему пользователю и API |
| Админ (дашборд, заказы, товары, пользователи, возвраты) | `mock-data` | Нет авторизации по роли, нет запросов к API |
| Модератор, Логистика | `mock-data` | То же |

### Типы и идентификаторы
- **`lib/types.ts`**: сущности с полем `id: string`. Бэкенд возвращает `_id` (MongoDB ObjectId в JSON как строка).
- **Карточка товара и ссылки**: используют `product.id` и `/product/${product.id}`. Для SEO и бэкенда удобнее поддерживать и `slug` (например `/product/[slug]` или `[idOrSlug]`).

### Утилиты
- **`formatPrice`** импортируется из `mock-data.ts` — лучше вынести в `lib/utils.ts` или `lib/format.ts`, чтобы не тянуть моки туда, где нужна только эта функция.

---

## 2. План по этапам

### Этап 0. Подготовка (инфраструктура)

**Цель:** единая точка входа к API, типы под ответы бэка, утилиты.

1. **Переменная окружения**
   - Добавить в проект (и в `.env.local` для разработки):
     - `NEXT_PUBLIC_API_URL=http://localhost:5000`
   - Создать `.env.example` с этой переменной (без секретов).

2. **API-клиент** (`lib/api.ts` или `lib/api/client.ts`)
   - Базовый URL из `process.env.NEXT_PUBLIC_API_URL`.
   - Функции для запросов: `get`, `post`, `patch`, `delete` с опциями.
   - Все запросы к API — через этот клиент.
   - Для запросов с авторизацией: заголовок `Authorization: Bearer <accessToken>` (токен брать из хранилища/контекста).
   - Для auth-эндпоинтов и refresh: `credentials: 'include'`, чтобы отправлялись/принимались httpOnly cookie с refresh.
   - При ответе 401: попытка обновить access через `POST /api/auth/refresh` (с `credentials: 'include'`), повтор исходного запроса с новым токеном; при неудаче — редирект на `/auth/login` или выброс ошибки для обработки в UI.

3. **Типы под бэкенд**
   - В `lib/types.ts` (или отдельный файл `lib/api-types.ts`):
     - Описать ответы API: продукт с `_id?: string`, `id?: string` (можно нормализовать `id = _id || id` при парсинге).
     - User (без password), Order, OrderItem, Category, Review, ReturnRequest — в формате, как отдаёт бэкенд (например `createdAt` как строка ISO).
   - Добавить тип для пагинированных ответов, если позже бэкенд начнёт отдавать `{ data, total, page, limit }`.

4. **Нормализация сущностей**
   - Функция `normalizeProduct(apiProduct)`: маппинг `_id` → `id`, при необходимости приведение полей (например дат) для использования в компонентах. Аналогично для категорий, заказов и т.д., если бэкенд отдаёт `_id`.

5. **Вынести `formatPrice`**
   - Перенести из `mock-data.ts` в `lib/utils.ts` или `lib/format.ts`.
   - Заменить импорты `formatPrice` с `@/lib/mock-data` на `@/lib/utils` (или `@/lib/format`) во всех компонентах.

---

### Этап 1. Авторизация

**Цель:** реальный вход/регистрация, хранение accessToken, отображение пользователя в хедере, защита маршрутов.

1. **Хранение токена и пользователя**
   - Вариант A: React Context (AuthContext) + при первом успешном логине сохранять `accessToken` в памяти (и при желании в `sessionStorage` для перезагрузки в той же сессии).
   - Вариант B: Zustand/другой store: `authStore` с полями `user | null`, `accessToken | null`, методы `setAuth`, `logout`; при инициализации приложения проверять наличие токена (и при необходимости вызывать `/api/auth/refresh`).
   - Refresh: при 401 в API-клиенте вызывать `POST /api/auth/refresh` с `credentials: 'include'`, в ответ взять `accessToken` и обновить контекст/store, затем повторить запрос.

2. **Логин** (`app/auth/login/page.tsx`)
   - При submit: `POST /api/auth/login` через API-клиент (body: email, password; `credentials: 'include'`).
   - При успехе: сохранить в контекст/store `user` и `accessToken`, редирект на `/account` (или на страницу, с которой пришли).
   - При ошибке: показать сообщение под формой (например из `response.message` или `errors`).

3. **Регистрация** (`app/auth/register/page.tsx`)
   - Собрать имя (имя + фамилия в одно поле или отдельно — как ожидает бэкенд), email, phone, password.
   - `POST /api/auth/register` с `credentials: 'include'`.
   - При успехе: сохранить `user` и `accessToken`, редирект на `/account`.
   - Ошибки валидации/дубликат email — показать в UI.

4. **Выход**
   - Вызвать `POST /api/auth/logout` с текущим accessToken (или без тела, но с cookie), очистить контекст/store (user, accessToken), при необходимости редирект на `/`.

5. **Хедер** (`components/site-header.tsx`)
   - Если пользователь авторизован: показать имя/аватар и кнопку «Выйти» (и/или пункт «Аккаунт»).
   - Если нет: ссылки «Войти» и «Регистрация» (как сейчас).
   - Использовать контекст/authStore для проверки `user`.

6. **Защита маршрутов**
   - Страницы: `/account`, `/checkout`, `/admin/*`, `/moderator`, `/logistics` — при отсутствии авторизации редирект на `/auth/login` (и при необходимости сохранить `returnUrl` в query, чтобы после входа вернуть на checkout/account).
   - Для `/admin/*`, `/moderator`, `/logistics`: после проверки токена опционально запрашивать `/api/users/me` и проверять `role`; при несовпадении роли — 403 или редирект на главную/account.
   - Реализация: HOC или компонент `ProtectedRoute` / middleware Next.js (если используешь App Router middleware), который проверяет наличие user/токена и роли.

---

### Этап 2. Каталог и товар (продукты + категории)

**Цель:** главная и каталог питаются с бэкенда; страница товара работает по id или slug.

1. **Категории**
   - Запрос: `GET /api/categories`.
   - Использовать в:
     - `components/home/categories-section.tsx` — заменить импорт `categories` из mock на данные из API (useEffect/useState или React Query/SWR).
     - При необходимости сделать категории доступными глобально (контекст или кэш), чтобы не дублировать запросы.

2. **Продукты**
   - Список: `GET /api/products?categorySlug=...&minPrice=...&maxPrice=...&search=...` (по необходимости).
   - Один товар: `GET /api/products/:idOrSlug` (бэкенд принимает и ObjectId, и slug).
   - Нормализация: приводить `_id` к `id` в типах/нормалайзере, чтобы компоненты могли продолжать использовать `product.id`.

3. **Главная**
   - `NewArrivalsSection`, `PopularSection`, `SaleSection`: получать продукты с API (например один запрос `GET /api/products`, затем на клиенте отфильтровать по `isNew` / рейтингу / скидке, либо добавить на бэкенде query-параметры и вызывать с ними).
   - `CategoriesSection`: см. выше, данные из API.

4. **Каталог** (`components/catalog/catalog-content.tsx`)
   - Загружать категории из API.
   - Загружать продукты: при смене фильтров (категория, цена, бренд, новинки, скидка) формировать query и вызывать `GET /api/products?...`.
   - Сохранить текущую логику фильтров и сортировки; при первом заходе можно взять `category` из `useSearchParams()` и передать в API.
   - Состояния загрузки/ошибки: показывать скелетон или сообщение при ошибке.

5. **Страница товара** (`app/product/[id]/page.tsx` и `components/product/product-detail.tsx`)
   - Роут оставить `[id]` или переименовать в `[idOrSlug]` и передавать param в API: `GET /api/products/${idOrSlug}`.
   - Для SSR: в `page.tsx` делать `fetch` к бэкенду (с полным URL из `NEXT_PUBLIC_API_URL`) и передавать продукт в `ProductDetail`; при ошибке 404 — показать «Товар не найден».
   - Отзывы: отдельно `GET /api/reviews/product/:productId` и подставлять в блок отзывов (productId = нормализованный id продукта с бэка).
   - В карточках и ссылках: использовать для перехода либо `product.id` (после нормализации с _id), либо `product.slug` и маршрут `/product/[slug]` — как договоритесь (единообразие с бэкендом по slug предпочтительно для SEO).

6. **ProductCard**
   - Ссылка: `href={/product/${product.id}}` или `href={/product/${product.slug}}` в зависимости от выбора выше. Тип Product должен иметь `id` (и при необходимости slug) после нормализации.

---

### Этап 3. Корзина и оформление заказа

**Цель:** корзина не теряется после перезагрузки; checkout создаёт заказ в API.

1. **Корзина (персистентность)**
   - Сохранять `cart-store` в `localStorage` (при изменении корзины — запись, при инициализации приложения — чтение).
   - Учитывать, что в корзине хранятся `productId`, `name`, `image`, `size`, `color`, `quantity`, `price`. productId после перехода на API будет строкой ObjectId (или slug — тогда на бэкенде при создании заказа нужно будет резолвить товар по slug/id).

2. **Checkout**
   - Перед отображением шагов проверять авторизацию; если нет — редирект на `/auth/login?returnUrl=/checkout`.
   - На шаге «Подтверждение» / «Оплатить»:
     - Собрать тело заказа в формате бэкенда: `items` (массив с productId, name, image, size, color, quantity, price), `total`, `address` (одной строкой или как принимает бэк), `deliveryMethod`, `paymentMethod`.
     - `POST /api/orders` с заголовком `Authorization: Bearer <accessToken>`.
     - При успехе (201): очистить корзину, показать экран «Заказ оформлен» и номер заказа из ответа (например `order._id` или orderNumber, если бэкенд начнёт его отдавать).
     - При ошибке (400/401/500): показать сообщение, не очищать корзину.

3. **formatPrice в checkout/cart**
   - Уже вынести в `lib/utils` на этапе 0; в checkout и cart импортировать оттуда.

---

### Этап 4. Личный кабинет (аккаунт)

**Цель:** профиль и заказы текущего пользователя с API.

1. **Данные пользователя**
   - Профиль: либо из контекста/store (user после логина), либо при заходе на `/account` запрашивать `GET /api/users/me` и обновлять контекст/store.
   - Вкладка «Профиль»: форма с именем, email, телефоном; кнопка «Сохранить» — пока бэкенд не отдаёт PATCH для профиля, можно только отображать данные (или добавить на бэке PATCH /api/users/me).

2. **Заказы**
   - `GET /api/orders/my` с токеном; отображать список в той же разметке, что сейчас, но с реальными данными. Номер заказа — `order._id` или переданный бэком код.

3. **Возвраты**
   - `GET /api/returns/my`; отобразить список запросов на возврат.

4. **Избранное**
   - Остаётся локальным (favorites-store); список товаров для вкладки «Избранное» — запрашивать по списку id из store (например несколько `GET /api/products/:id` или один эндпоинт с фильтром по id, если появится на бэке). Пока можно оставить фильтрацию по локальным id и запрашивать продукты с API по одному/пакетом.

5. **Защита**
   - Страница `/account` только для авторизованных; иначе редирект на логин.

---

### Этап 5. Админ-панель, модератор, логистика

**Цель:** все списки и действия через API, доступ по ролям.

1. **Проверка роли**
   - При заходе на `/admin/*` проверять `user.role === 'admin'` (и при необходимости moderator для части разделов).
   - Для `/moderator` — роль moderator или admin.
   - Для `/logistics` — роль logistics или admin.
   - Иначе редирект или 403.

2. **Админ: заказы** (`app/admin/orders/page.tsx`)
   - `GET /api/orders` (список всех заказов).
   - Таблица: заказ, клиент (можно запросить пользователей или хранить имя в заказе — как у вас в API), товары, сумма, статус, дата.
   - Смена статуса: `PATCH /api/orders/:id/status` с `{ status }` (Select onChange вызывать этот запрос).

3. **Админ: товары** (`app/admin/products/page.tsx`)
   - `GET /api/products` для списка.
   - Кнопка «Добавить товар» — форма/модалка или отдельная страница; `POST /api/products` с полями по схеме бэка.
   - Редактирование: `PUT /api/products/:id`; удаление: `DELETE /api/products/:id`.

4. **Админ: категории**
   - Если есть страница: `GET /api/categories`, создание/редактирование/удаление через соответствующие эндпоинты.

5. **Админ: пользователи** (`app/admin/users/page.tsx`)
   - `GET /api/users` (с токеном admin).
   - При необходимости смена роли: `PATCH /api/users/:id/role`.

6. **Админ: возвраты** (`app/admin/returns/page.tsx`)
   - `GET /api/returns`; смена статуса: `PATCH /api/returns/:id/status`.

7. **Модератор / Логистика**
   - Подключить те же API (отзывы, возвраты, заказы) в соответствии с правами; данные не из mock-data.

8. **Дашборд админа** (`app/admin/page.tsx`)
   - Агрегаты (количество заказов, выручка, товаров, пользователей) — либо считать на клиенте по данным с API, либо добавить на бэкенде эндпоинт статистики и вызывать его.

---

### Этап 6. Улучшения и полировка

1. **Обработка ошибок**
   - Единый формат ошибок от API (message, errors); показывать тосты или inline-сообщения в формах.
   - Сетевые ошибки: «Нет соединения», «Попробуйте позже».

2. **Загрузки**
   - Скелетоны или спиннеры на списках (каталог, заказы, админ); кнопки «Сохранить»/«Войти» в состоянии loading при запросе.

3. **Отзывы на странице товара**
   - Если пользователь авторизован — форма «Оставить отзыв»; `POST /api/reviews` с productId, rating, text.
   - Список отзывов: `GET /api/reviews/product/:productId`; отображать только одобренные или все — по логике бэка.

4. **Поиск в хедере**
   - При вводе и отправке — переход на `/catalog?search=...` и вызов `GET /api/products?search=...` в каталоге.

5. **Мок-данные**
   - После перехода всех экранов на API: удалить или сильно сократить `mock-data.ts`, оставив только то, что нужно для fallback/тестов (например пустые массивы и formatPrice уже в utils).

6. **TypeScript**
   - В `next.config.mjs` убрать `ignoreBuildErrors: true` после приведения типов в порядок (нормализация API-ответов и типы в lib/types).

---

## 3. Порядок внедрения (кратко)

| # | Задача | Зависимости |
|---|--------|-------------|
| 0.1 | NEXT_PUBLIC_API_URL, .env.example | — |
| 0.2 | API-клиент (get/post/patch/delete, 401 → refresh) | 0.1 |
| 0.3 | Типы под API, нормализация _id → id | — |
| 0.4 | Вынести formatPrice в lib/utils | — |
| 1.1 | Auth store/context (user, accessToken) | 0.2 |
| 1.2 | Логин/регистрация → API, сохранение токена | 1.1 |
| 1.3 | Хедер: пользователь / Выйти | 1.1 |
| 1.4 | Защита маршрутов (account, checkout, admin) | 1.1 |
| 2.1 | Категории и продукты с API (главная, каталог) | 0.2, 0.3 |
| 2.2 | Страница товара по id/slug, отзывы с API | 0.2, 0.3 |
| 2.3 | ProductCard: ссылка по id или slug | 2.1 |
| 3.1 | Корзина в localStorage | cart-store |
| 3.2 | Checkout: POST /api/orders, экран успеха | 1.1, 0.2 |
| 4.1 | Аккаунт: /me, заказы, возвраты с API | 1.1, 0.2 |
| 5.1 | Админ: заказы, товары, пользователи, возвраты с API + проверка роли | 1.1, 0.2 |
| 6.1 | Ошибки, загрузки, поиск, отключение ignoreBuildErrors | по мере готовности |

---

## 4. Файлы для изменения (сводка)

- **Новые:** `lib/api.ts` (или `lib/api/client.ts`), `lib/format.ts` (или расширить utils), контекст/store auth, компонент/HOC защищённого маршрута, при необходимости `lib/api-types.ts`.
- **Изменить:** `lib/types.ts` (поддержка _id/id), `lib/utils.ts` (formatPrice), `lib/mock-data.ts` (убрать formatPrice, позже минимизировать).
- **Страницы/компоненты:** все, где импортируется `mock-data` (см. таблицу в разделе 1), плюс login, register, site-header, checkout-content, account-content, catalog-content, product/[id]/page, product-detail, admin-страницы, moderator, logistics, home-секции.
- **Конфиг:** `.env.local`, `.env.example`, при желании `next.config.mjs` (images, env).

После выполнения этого плана фронтенд будет полностью работать с бэкендом MonDiva и готов к дальнейшему развитию (пагинация, аналитика, сброс пароля и т.д.).
